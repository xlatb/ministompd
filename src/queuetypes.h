#include <time.h>  // struct timespec

#ifndef MINISTOMPD_TYPES_H
#define MINISTOMPD_TYPES_H

struct queue;
typedef struct queue queue;

struct queueconfig;
typedef struct queueconfig queueconfig;

struct storage;
typedef struct storage storage;

struct framerouter;
typedef struct framerouter framerouter;

struct subscription;
typedef struct subscription subscription;

struct connection;
typedef struct connection connection;

// *** Queue ***
struct queue
{
  const bytestring  *name;
  storage           *storage;
  framerouter       *framerouter;
  const queueconfig *config;
};

// *** Storage ***

typedef enum
{
  STORAGE_TYPE_MEMORY     = 0,
  STORAGE_TYPE_SERVERINFO = 1
} storage_type;

struct storage
{
  storage_type type;
  queue       *queue;
  union
  {
    struct storage_memory     *memory;
//    struct storage_serverinfo serverinfo;
  } u;
};

// Handle for a given frame within a storage. These can be reused after frames
//  are dequeued, so they are not unique over the lifetime of the storage.
typedef int storage_handle;

// *** Queueconfig ***
typedef enum
{
  QC_DIST_SINGLE,
  QC_DIST_BROADCAST
} qc_distribution;

typedef enum
{
  QC_FULL_ERROR,
  QC_FULL_DROP_OLDEST,
  QC_FULL_DROP_NEWEST
} qc_full_action;

typedef enum
{
  QC_REJECT_DROP,
  QC_REJECT_REDIRECT
} qc_reject_action;

struct queueconfig
{
  qc_distribution  distribution;

  storage_type     storage_type;
  list            *storage_args;

  int              size_max;
  qc_full_action   full_action;

  int              age_max;
  qc_reject_action retire_action;

  int              nack_max;
  qc_reject_action nack_action;
};

// *** Framerouter ***

struct framerouter
{
  list *subscriptions;
  int   subscription_index;  // Index of slot of next subscription to route to

  list *dispatches;
};

// *** Subscription ***
// A subscription is a binding between a queue and a connection that wants to
//  consume frames from it.

typedef enum
{
  SUBSCRIPTION_ACK_AUTO              = 1,
  SUBSCRIPTION_ACK_CLIENT            = 2,
  SUBSCRIPTION_ACK_CLIENT_INDIVIDUAL = 3
} sub_ack_type;

struct subscription
{
  queue             *queue;
  struct connection *connection;
  const bytestring  *client_id;  // The subscription id provided by the client
  const bytestring  *server_id;  // The subscription id generated by the server
  sub_ack_type       ack_type;
  hash              *deliveries;  // Deliveries on this subscription keyed by message-id
  uint64_t           next_seqnum;
//  queue_local_id last_qlid;  // The qlid of the most recent frame consumed by this subscription
};

// -- Dispatch --
// There is one dispatch record on a framerouter per frame being sent

struct dispatch
{
  frame          *frame;
  storage_handle  handle;
  struct timespec createtime;  // The time the dispatch item was created
};

// -- Delivery --
// There is one delivery record on a subscription per frame consumption in progress

typedef enum
{
  DEL_STATUS_WRITE,  // Writing frame to client
  DEL_STATUS_WAIT,   // Waiting for response from client
  DEL_STATUS_ACK,    // Acknowledged
  DEL_STATUS_NACK,   // Rejected
} delivery_status;

struct delivery
{
  frame          *frame;
  uint64_t        seqnum;  // Sequence number within subscription
  delivery_status status;
  struct timespec createtime;  // The time the delivery item was created
  struct timespec writetime;  // If status is not DEL_STATUS_WRITE, the time it was written to the client
  struct timespec completetime;  // If status is not DEL_STATUS_WRITE or DEL_STATUS_WAIT, the time of the ACK or NACK
};

#endif
